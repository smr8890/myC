## 题目一览
| 题号 | 名称               | 类型               | 难度 |
| ---- | ------------------ | ------------------ | ---- |
| 1457 | 图像               | 递归               | 2    |
| 1550 | 马里奥             | 双指针             | 2    |
| 1561 | 制药               | 二分               | 2    |
| 1577 | 聚会               | 排序               | 2    |
| 1584 | 极大极小堆         | STL，优先队列      | 3    |
| 1433 | Swap Digits        | BFS                | 3    |
| 1532 | Fibonacci进制      | 贪心               | 3    |
| 1534 | Black White Chess  | DFS                | 3    |
| 1545 | 幂                 | 递归               | 3    |
| 1568 | 完全二叉排序树     | 二叉树             | 3    |
| 1585 | 数字               | BFS                | 3    |
| 1586 | 积                 | 贪心，双指针       | 4    |
| 1587 | 异或树             | DFS                | 3    |
| 1448 | 按位与             | 双指针             | 4    |
| 1460 | 距离               | 双指针，二分，枚举 | 4    |
| 1555 | 数组               | 二分、双指针       | 4    |
| 1566 | 删除               | 排序，贪心         | 4    |
| 1570 | 斐波拉契数的平方和 | 数学，快速幂       | 4    |
| 1581 | 斐波拉契+1         | 数学，快速幂       | 4    |
| 1390 | 字母计数           | 递归，表达式解析   | 5    |

## 1457 图像
### 题意
四分树顺序扫描图像，提供扫描序号，求坐标。
### 思路
显然不可能暴力模拟。

1.  枚举或者公式求出目前序号![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)所需要的![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df378375e7693bdcf9535661c023c02e.svg)，递归求解问题![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/f8453092c247a871cb7b76f7c0aab8a5.svg)。
2. 对于问题![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/f8453092c247a871cb7b76f7c0aab8a5.svg), 易知 ![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/9f0257de6d1506d72973f542bee7dca2.svg)宽度![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/c9b08ae6d9fed72562880f75720531bc.svg)的图像的像素点数![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/d5dc552da830f92fd46e7e2137be28e7.svg) 和 在![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/055ce37910d06a8239ef5a1ee87765f5.svg)宽度的图像中四个子图的左上角坐标分别为![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/2a6122538ce97f3ec31649515d6a8cf3.svg)。
3. 判断序号![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)位于哪个子图，将返回坐标更新，并将![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)减去之前子图的像素总数，继续递归即可。
## 1550 马里奥
### 题意
马里奥跳砖块，马里奥最多跳的距离是![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/56c1b0cb7a48ccf9520b0adb3c8cb2e8.svg),要坐标![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/53072c2388d69edc65c2377681e4e87c.svg)的砖块跳到坐标![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/c9b08ae6d9fed72562880f75720531bc.svg)的砖块上，中间有![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df378375e7693bdcf9535661c023c02e.svg)个砖块，问最少去掉几块中间的砖块，使得马里奥无法完成任务。
### 思路
很经典的双指针题。

1. 读入所有的砖块，其中`a[0]=1,a[n+1] = w`
2. 如果一开始就可以跳过去，那么直接输出`"-1"`。
3. 左右指针初始都指向![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg), 答案初始为![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df378375e7693bdcf9535661c023c02e.svg)
4. 不断移动右指针，直到左右指针指向的砖块距离差大于![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/56c1b0cb7a48ccf9520b0adb3c8cb2e8.svg)或者已到最右边。
5. 更新答案
6. 如果到达最右边或者答案为![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)就结束。
7. 左指针右移
## 1561 制药
### 题意
一份药需要![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df378375e7693bdcf9535661c023c02e.svg)种药材，第![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)种药材需要![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/5d496a3b872073b90e3b920cacfc3dc6.svg)份。![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/4760e2f007e23d820825ba241c47ce3b.svg)个位置种药材，第![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)种药材每次可以种得![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/2a1e6a280559d96bdb68224b12ce4487.svg)份药材。问最多能获得多少份药？
### 思路
典型的二分题

1. 二分药数![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/712ecf7894348e92d8779c3ee87eeeb0.svg)
2. 检验获得![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/712ecf7894348e92d8779c3ee87eeeb0.svg)份需要的药材需要多少位置来种植 ![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/e2686de6ba5f2ec380b7cccd073241b3.svg)
3. 求![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/712ecf7894348e92d8779c3ee87eeeb0.svg)的上限即可。
## 1577 聚会
### 题意
小明想办个聚会，他问了自己的朋友，第_i_位朋友说至少有![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/5d496a3b872073b90e3b920cacfc3dc6.svg)个人会去（不含他自己），他就去。
小明喜欢热闹，他想知道聚会的人数最多是多少人？
### 思路

1. 对![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/5d496a3b872073b90e3b920cacfc3dc6.svg)排序
2. 枚举，如果![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/33f366f5cf8c35512f09499d5f8f857b.svg)结束
## 1584 极大极小堆
### 题意
一个数列，每次可以执行两个操作之一： 1. 取极小和次小，其差值加入数列； 2. 取极大与次大，其差值入数列。
问进行![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/f29219be34b160369c88fab81ea65712.svg)次操作以后，是否只含一个元素![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)。
### 思路
此题并不需要动态规划，直接模拟每次都执行操作2模拟即可。但是证明稍微复杂一些，大家要学会怎么思考证明这个结论。
证明：
不妨设数列![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/de951302f41d4707b9d80ca1af34dd0f.svg)是有序的，如果数列不可得![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg),那么按以上操作（下称策略）自然也无法得![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)。
命题： 当数列可以得到![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)与按策略得到![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)等价。
必要条件显然成立，下面证明充分条件。
当![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/27576ef4ca36a588ac8486a592a09e3f.svg)时，![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/ff0327b7e73aabe2653044f91788a9c4.svg)，如果不等价，那么![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/ed8b8e96688a644c6dcab56603baa6b8.svg)且 ![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/611e38eec7a872e02eabed774a169d48.svg)。
因为![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/85e8b12188f4a0f04d4aefb753f4f214.svg), 那么 ![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/5d34c3843e4b7f5e6a340a3af0515dab.svg)且 ![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/39fa8ce1fd7a228853aff37e1de9f19c.svg),与![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/ed8b8e96688a644c6dcab56603baa6b8.svg)矛盾。所以，![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/27576ef4ca36a588ac8486a592a09e3f.svg)时，命题成立。
令![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/69bb54443f37ae47d54e5eb6fd4d6b45.svg)时，命题都成立，当![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/038f01b2fd948b32867c3164bf007f40.svg)时，![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/4c18b0b1cbd3f49ffbe7295d2301ddaa.svg)，如果可得![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg), 那么构造![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/249f76e326874013f8c6b452ddff49f8.svg)必然可得![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)，由于![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/0a3322330df1337eae0f259e8379bf65.svg)时命题成立，那么按策略![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/25fb1f2f817528924b3d0cc4d7c6bf8a.svg)必然能得![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/5ac084b916aecfc127b3a6466369e4ab.svg), 所以按策略会得到![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/8d55f1169df76ac406c437a9f1303cd2.svg)。显然，继续按策略会得到![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)。
## 1433 Swap Digits
### 题意
一个十进制数，最多交换![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)次相邻的数码，问最多能产生多少个不同的不含前导![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)的数。
### 思路
典型的BFS题目。
BFS中使用hash判重，那么hash表的元素数量即为答案。
## 1532 Fibonacci 进制
### 题意
位权为Fibonacci数，系数为![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)或者![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/53072c2388d69edc65c2377681e4e87c.svg)，表达一个数的最小Fib进制的数位串，视其为二进制，求其十进制值。
### 思路
这题是1236 Fibonacci的姊妹题，1236是求最大，所以直接按Fib数贪心即可，但这个题没有那么直接。
令![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/74550f3ed141556f2c01648f88e63194.svg)。
我们观察到如果![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/dee4df7b0d8774f566d4fa13dedce610.svg),那么必然其为![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/f54bdfec65035c460a992f9abc816d3b.svg)。所以，当![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/e8b798d43f38a7b0089ee467c1578e6c.svg)时，才可能是![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/85721c8dd103979ba40845fcf315aef1.svg)。
所以我们按照![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/59c7b370a04f092d864086c4e76ea17e.svg)进行贪心即可。
## 1534 Black White Chess
### 题意
![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/685f75f4a8065fd839948431e93b294c.svg)的棋盘，每格上右黑棋或者白棋。可以把每行每列每![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/10aa54bbdcae60bea1c1e8bcc141bf37.svg)的棋子翻转，问是否能从A局面变成B局面？
### 思路
很多同学思维比较僵化，一看就直接上bfs，从A搜到B，由于样例数极大![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/00153c1dfa7b331d8f8aea29e707b035.svg),这样必然是超时的。
观察这个题，其实就是很简单的染色题，用dfs或者bfs都可以，将所有局面(总数是![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/3cc2bd760b4297230f9959af9209b0f6.svg))进行染色，然后根据给的局面判断其是不是属于同一种颜色即可。
另外，可以利用位压缩技术来表示局面和执行操作，提高运行效率。
## 1545 幂
### 题意
表达式由下列产生规则生成

1. ![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/c3775e4800cb1a5b160985845315c7b3.svg)是表达式，其中![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/56c1b0cb7a48ccf9520b0adb3c8cb2e8.svg)是![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/a82818919805c0678ec678560b68e2f8.svg)中的整数
2. 若![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/55fc237afbe535f7d8434985b848a6a7.svg)是表达式，那么![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/c31384a23fea77c08233a8f873653e91.svg)也是表达式
3. 若![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/75c7dd34b38cb2bfaa82c1c9ef221dd5.svg)是表达式，那么![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/bbe13e382eaf98b27675d8fb6561b571.svg)也是表达式

其中 ![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/ea9d762c61bba38ceac8234b3f4616e2.svg)表示![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/b67c3aca1bcc34aec861fef4fbf09535.svg)，![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/8e74af108476dddf9b4e05afcb063654.svg)表示![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/8975c29cd9a92cdcf9d0009080b22012.svg)。
求一个合法表达式的值。
### 思路
表达式解析题，使用递归下降解析即可。
dfs(s,e): 解析表达式字符串![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/27fdc2b62b21dace86b0fb5d68100d68.svg)区间的值

1. 找到匹配的右括号后面的位置![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/d4cd21d60552e207f237e82def9029b6.svg)
2. 如果![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/b816754f8a4419a66c12776fe260608c.svg),`ans = dfs(p,e)`
3. 如果![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/f31f02a9fbf9fcf642f2d91acca81608.svg)是产生式![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/53072c2388d69edc65c2377681e4e87c.svg), `ans += d`
4. 否则，`a = dfs(s+1,p-1)`，`ans += a*a`
## 1568 完全二叉排序树
### 题意
问一个空的二叉排序树，如果依次插入若干个节点，它是否是完全二叉排序树？
### 思路
很多同学很机械地模拟二叉排序树的插入，然后再判断是不是一棵完全二叉树，这些代码又臭又长，还容易写错。我们知道堆就是完全二叉树，所以这题完全可以利用堆存储的性质。显然，如果是完全二叉树的话，节点数即是数组大小(从1开始算)，这样我们利用堆存储（节点`i`的左孩子节点为`i<<1`,右孩子节点为`i<<1|1`），如果超过数组大小，那么必然不是完全二叉排序树，否则是的。
## 1585 数字
### 题意
一个数不断执行加减一，乘除二的运算，最少多少次能得到另外一个数。
### 思路
BFS模板题。
```cpp
BFS(G,s,e) //图G，起点s，重点e
    color[:] = WHITE; dist[:] = inf; prev[:] = NULL;
    队列Q;
    Q.enque(s);color[s] = GRAY;dist[s] = 0;
    while (Q非空)
        u = Q.front(); Q.deque(); 
        if u == e return true;
        for each v in adj[u]
            if color[v] == WHITE						
                color[v] = GRAY;
                dist[v] = dist[u] + 1;
                prev[v] = u;
                Q.enque(v);
        color[u] = BLACK;
    return false;

```
## 1586 积
### 题意
![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df378375e7693bdcf9535661c023c02e.svg)个整数，选![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)个，求最大积。注意，整数可以是负数。
### 思路
由于![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df378375e7693bdcf9535661c023c02e.svg)最大有![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/38f10dfc60376e1d78da6027f1a33383.svg)，所以直接计算必须用大数运算，我们要想办法避免掉大数运算。
如果最大积为负，那么我们将数组按绝对值从小到大排序，依次选![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)个，计算即可。
否则，我们将数组从小到大排序，如果![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)为奇数，那么先选掉最大数。剩下的数里，每次看头尾的各2个，看谁的积大，就选这两个数，直到选完![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)个数。
怎么知道最大积是负数了？我们可以执行第二策略，如果第二策略中，![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)是奇数且全部都是负数，或者按此策略选完结果为负数，那么最大积必然是负数。 首先，显然![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)是奇数且全部都是负数时，最大积必然是负数；另外，按此策略，如果存在![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)被选时，最大积为![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg); 如果不存在![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)被选时，只有一次会出现选负数积的情况，即被选的两个数正好是正负交界的两个数。此时必然是没有其他可选，才会选这两个数，所以最大积必然为负数。
下面我们证明我们的策略是对的。
如果最大积为非负数，如果![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)是奇数，那么最大值必然要为非负数，否则矛盾，所以选最大的数，必然不会使得结果变坏；选完以后，情况就变成![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)是偶数的形式。对于偶数情况，每次选两个最大可能的积，必然使得最终积最大。
如果最大积为负数，显然按照绝对值排序，依次选![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)个数的积为最大。
## 1578 异或树
### 题意
一棵树，节点上是![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)或者![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/53072c2388d69edc65c2377681e4e87c.svg)。你每次操作可以将某个子树上的所有节点翻转，请问至少多少次操作可以使得整个树为全![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)或者全![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/53072c2388d69edc65c2377681e4e87c.svg)。
### 思路
注意到，根节点只会在对整个树操作时被翻转。偶数次翻转相当于没有翻转，所以一个节点最多翻转一次，即当节点值不等于目标值时，翻转计数器+1，然后递归翻转其子节点即可。
所以，对于目标值是全![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)和全![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/53072c2388d69edc65c2377681e4e87c.svg)都算一次，取小的。

## 1448 按位与
### 题意
对于数列，问最长的区间，这个区间内最多去掉![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)个数，其按位与的结果是非![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/22d0feea96d3bb2fc273f7598ce748c1.svg)。
### 思路

1. 先考虑如果是个01串，求最长区间，最多去掉k个字符，使得区间内都是1。这可以很容易用双指针解决
   1. 右指针不断右移，直到结尾或者遇到k+1个0
   2. 更新答案
   3. 左指针不断右移，直到遇到0，然后再右移一位
2. 对于原题，那么我们只要依次枚举所有位，对于每一位就是问题1.
## 1460 距离
### 题意
![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df378375e7693bdcf9535661c023c02e.svg)个坐标上的点，只允许放在指定的![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/4760e2f007e23d820825ba241c47ce3b.svg)个区间内，求这些点最小距离的最大值（就是尽量让两个点离远点）。结果可能需要输出一个分数。
### 思路

1. 对区间进行排序
2. 可以先预处理合并一些相交的区间（不合并大概慢![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/132a593d56de4d3647e4c35d7737fc44.svg),但并不会超时），使用双指针即可。
3. 二分最大间隔，这个值是个浮点数 ![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/712ecf7894348e92d8779c3ee87eeeb0.svg)
4. 由于![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/712ecf7894348e92d8779c3ee87eeeb0.svg)化成分数的分母最大不超过![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/f29219be34b160369c88fab81ea65712.svg)，所以枚举分母，求一个最接近分数![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/bc24976004589dce488e1f3807812dd0.svg)，最后通分即可。
## 1555 数组
### 题意
一个由生成式产生的数组，任取两个（可以是同一个）元素，其和值在给定的范围内，求取法数量。![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/61bf5f6de4ee9026260b3556924a909d.svg)
### 思路

1. ![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/377630b36340ebdea9ed46f82b5e1ee0.svg)
2. 枚举产生式，产生数组，然后排序
3. 最小数的2倍大于R或者最大数的2倍小于L，无解
4. 二分查找不小于![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/b9ca527a5072afb9cba5b56f84725e83.svg)在数组中的下限。
5. 二分查找大于![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/5f065612ef12f1a2c82835e9d670e117.svg)在数组中的上限。
6. 在这个范围内，对向双指针来计算![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/239b2176ed8718fa152a8333edb78c06.svg)。
   1. 右指针不断左移，直到左右指针指向的和小于等于![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/712ecf7894348e92d8779c3ee87eeeb0.svg)或交错。
   2. 计算贡献
   3. 左指针右移
   4. 左右指针交错退出，否则重复以上步骤
## 1566 删除
### **题意**
![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df378375e7693bdcf9535661c023c02e.svg)个数，每次可以将差值不超过![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df976ff7fcf17d60490267d18a1e3996.svg)的两个数合并，得到他们的平均值向下取整。问如此不断操作，是否能使得数组变成![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/53072c2388d69edc65c2377681e4e87c.svg)个元素。
### 思路

1. 按从小到大排序
2. 从小到大处理，计算所有点位的合并值，得到数组`max`
3. 从大到小处理，计算所有点为的合并值，得到数组`min`
4. 枚举汇合点![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/2443fbcfeb7e85e1d62b6f5e4f27207e.svg),前面使用![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/5112112730d4affdc7f4fe4022000a40.svg),后面使用![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/decb2106c362b8deddff6d55bad47dd8.svg), 看是否存在![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/ec55ffcc38c92cf76c2d1d5a2de813b0.svg), 存在即成功，否则失败。

时间复杂度为![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/79541359ff4cbbcbb51274fc50abf4bd.svg)
我们证明一下这种贪心是正确的：
假设我们有![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/de16a457b99d777a3d3873178023bfff.svg),  那么我可以得到的方案为![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/12b7d09ef07c9b540a8218014ff68a37.svg),![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/369977b747da2a2dffeed29d167daf17.svg),![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/c87ba44ad4ab2312e4dc98cd2c800748.svg), 显然，方案1的值最大。另外单元素和两元素显然也是按从小到大顺序处理得到的值最大。
所以，当![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/dd75f90c36509aff0826930d6c39e958.svg)时，我们使用从小到大得到的值时最大的。
当![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/258f501d96fbac350be99a845e5dcd66.svg)时，我们定义![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/3ff6e37f1a67d643fa5a80f0dd0524fc.svg)表示从![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)到![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/036441a335dd85c838f76d63a3db2363.svg)按从小到大处理的得到的值。假设存在一个额外的处理，使得到的值大于![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/811ee1446a20de0cd052cbb5c59b82cf.svg), 即
![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/f6fdbf9046845684258022577b496f2e.svg),![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/c59f02c43f2d71f6b2ae2b4d60743666.svg)表示对集合![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/947e1e92deb0a63188dd4018d6fb7b9d.svg)处理得到最大值。 由于 ![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/7a2eac8080fd9e35cbab724069825860.svg)，那么我可以知道，当![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/dd75f90c36509aff0826930d6c39e958.svg)时按从小到大处理得到结果时值最大，那么必然![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/d8cb5e434d2e24bc28479dbace495381.svg)。等号只有在所有元素相等时成立。
所以可以证明按从小到大处理得到值是最大的。 相似地，可以证明从大到小的值是最小的。

几个其他贪心的反例
```cpp
---- 正序成功，逆序不成功，结果Yes
3 4
1 5 7
---- 逆序成功，正序不成功，结果Yes
3 4
1 3 7
---- 正序+逆序都不成功，结果Yes
6 4
1 5 7 8 10 13

```

## 1570 斐波那契数的平方和
### 题意
求![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/59474f21995fcb21987da4f09b45416a.svg)
### 思路
![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/a53d1213a1b6678b43afad786c99cf64.svg),那么 ![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/2731b6b34d6a3175ee7b6448c3f850e1.svg)。
可以很容易手工枚举计算，猜出这个结论
![](https://cdn.nlark.com/yuque/__latex/f1a7f75cda7b872468ee106cfd30fe58.svg#card=math&code=%5Cbegin%7Barray%7D%7Brrrrrrc%7D%0Afib%3A%20%26%201%20%26%201%20%26%202%20%26%203%20%26%205%20%26%20%5Cldots%20%5C%5C%0AS%3A%20%20%20%26%201%20%26%202%20%26%206%20%26%2015%20%26%2040%20%26%20%5Cldots%0A%5Cend%7Barray%7D&id=Zb2Za)
如果你数学好一点，也很容易正面推出这个结论。
![](https://cdn.nlark.com/yuque/__latex/bb65bf087b5559aef77cd4b6ae288362.svg#card=math&code=%5Cbegin%7Barray%7D%7Brcl%7D%0AS%28n%2B1%29%20-%20S%28n%29%20%26%20%3D%20%26%20fib_%7Bn%2B1%7D%5E2%20%3D%20fib_%7Bn%2B1%7D%5Ctimes%20%28fib_%7Bn%2B2%7D%20-%20fib_%7Bn%7D%29%20%3D%20fib_%7Bn%2B1%7D%20%5Ctimes%20fib_%7Bn%2B2%7D%20-%20fib_%7Bn%7D%20%5Ctimes%20fib_%7Bn%2B1%7D%20%5C%5C%0AS%28n%29%20-%20S%28n-1%29%20%26%20%3D%20%26%20fib_%7Bn%7D%20%5Ctimes%20fib_%7Bn%2B1%7D%20-%20fib_%7Bn-1%7D%20%5Ctimes%20fib_%7Bn%7D%20%5C%5C%0A%5Cldots%20%5C%5C%0AS%281%29%20-%20S%280%29%20%26%20%3D%20%26%20fib_1%20%5Ctimes%20fib_2%20-%20fib_0%20%5Ctimes%20fib_1%20%0A%5Cend%7Barray%7D&id=xEc2v)所以，![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/30091a8d74b189b547b70e22344f6d74.svg)
当然，猜出结论后，使用数学归纳法也很容易证明，这里就不赘述了。
由于![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df378375e7693bdcf9535661c023c02e.svg)最大有![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/76965611c532fd70ebf787cc5631c3e9.svg)，所以循环求肯定会超时，这里我们使用矩阵快速幂来求即可，时间复杂度为![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/411204a24e10d7a232473acfff8273bf.svg)。
## 1581 斐波那契+1
### 题意
_求 _

![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/6362d58dc9681991aa0ce2a26b09da8a.svg)

### 思路
![](https://cdn.nlark.com/yuque/__latex/4ae43049fec4e67ff901935df01dd847.svg#card=math&code=A%3D%5Cbegin%7Bpmatrix%7D%0A1%20%26%201%20%26%200%5C%5C%0A1%20%26%200%20%26%200%5C%5C%0A1%20%26%200%20%26%201%5C%5C%0A%5Cend%7Bpmatrix%7D&id=DfZwV)
![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/efdc0b20d5d2abf8149e3ad47276658e.svg)
矩阵快速幂即可。

## 1390 字母计数
### 题意
一个产生式表示只含小写英文字母的字符串，求各字母出现的次数。
产生式为![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/41cdb6a0150bdf7e43b07bc20cfc671d.svg)，其中![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/b891664b42113aee13f0bac25eb998e5.svg)是字母,![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/df378375e7693bdcf9535661c023c02e.svg)是大于![](https://smr-typora.oss-cn-guangzhou.aliyuncs.com/img/53072c2388d69edc65c2377681e4e87c.svg)的整数。
### 思路
这种题使用下推自动机完成，可以按产生式写出各种产生式的递归形式即可。
```cpp
/*
 *  dfs函数实现计算输入字符串buf,[s,e)区间内字符出现次数，存放在c数组中。
 *  s: int, e : int , c : long long *
 */
dfs(s,e,c):
	如果首字母是'(': 	  // S -> (S)nS 形式
    	找到匹配的右括号位置为i。 
    	dfs(s+1,i-1,c1)
        查找i后的数字串，数字串的结束位置为j。
    	将其转换成数字t,并乘入数字c1。
    否则：	// S -> cnS 或者 s -> cS 形式
        找到s+1开始的数字串，数字串结束位置为j。
        如果存在数字串，将其转换成数字t，否则t=1。
        c1中的s位置字符的数量为t,其他为0。
    dfs(j+1,e,c2)
    将c1和c2合并成c
        
```